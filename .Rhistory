levels = c("0001","0010","0100","1000",
"0011","0101","0110","1010","1100",
"0111","1011","1101","1110","1111"))
table(captHistory$Site_ID, captHistory$captureHistory)
capSummary <- table(captHistory$Site_ID, captHistory$captureHistory)
crPiFun <- function(p) {
p1 <- p[,1]
p2 <- p[,2]
p3 <- p[,3]
p4 <- p[,4]
cbind("0001" = (1-p1) * (1-p2) * (1-p3) * p4,
"0010" = (1-p1) * (1-p2) * p3 * (1-p4),
"0100" = (1-p1) * p2 * (1-p3) * (1-p4),
"1000" = p1 * (1-p2) * (1-p3) * (1-p4),
"0011" = (1-p1) * (1-p2) * p3 * p4,
"0101" = (1-p1) * p2 * (1-p3) * p4,
"0110" = (1-p1) * p2 * p3 * (1-p4),
"1010" = p1 * (1-p2) * p3 * (1-p4),
"1100" = p1 * p2 * (1-p3) * (1-p4),
"0111" = (1-p1) * p2 * p3 * p4,
"1011" = p1 * (1-p2) * p3 * p4,
"1101" = p1 * p2 * (1-p3) * p4,
"1110" = p1 * p2 * p3 * (1-p4),
"1111" = p1 * p2 * p3 * p4)
}
p<- matrix (0.4,2,3)
crPiFun(p)
p
p<- matrix (0.4,2,4)
crPiFun(p)
rm(p)
umf.cr1 <- unmarkedFrameMPois(y = as.matrix(capSummary), siteCovs = covs, piFun = "crPiFun")
matrix(1, 3, 7)
o2y <- matrix(1, 4, 14)
umf.cr1 <- unmarkedFrameMPois(y = as.matrix(capSummary), siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
capSummary <- as.matrix(capSummary)
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
class(capSummary) <- "matrix"
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
crNull <- multinomPois(~1 ~1 umf.cr1, engine = "R")
crNull <- multinomPois(~1 ~1, umf.cr1, engine = "R")
crNull
backTransform(crNull, type = "det")
backTransform(removalNull, type = "det")
round(getP(crNull), 2)[1,]
crDay <- multinomPois(~dayOfYear, ~1, umf.cr1, engine = "R")
View(covs)
crDay <- multinomPois(~dayOfYear ~1, umf.cr1, engine = "R")
crDay
crNull
backTransform(crNull, type = "state")
removalDay
summary(removalDay)
backTransform(removalDay, type = "State")
backTransform(removalDay, type = "state")
summary(removalNull)
backtransform(removalNull, type = "state")
backTransform(removalNull, type = "state")
exp(-0.962)
exp(-0.962)/(1+exp(-0.962))
crPiFun <- function(p) {
p1 <- p[,1]
p2 <- p[,2]
p3 <- p[,3]
p4 <- p[,4]
cbind("0001" = (1-p1) * (1-p2) * (1-p3) * p4,
"0010" = (1-p1) * (1-p2) * p3 * (1-p4),
"0100" = (1-p1) * p2 * (1-p3) * (1-p4),
"1000" = p1 * (1-p2) * (1-p3) * (1-p4),
"0011" = (1-p1) * (1-p2) * p3 * p4,
"0101" = (1-p1) * p2 * (1-p3) * p4,
"0110" = (1-p1) * p2 * p3 * (1-p4),
"1010" = p1 * (1-p2) * p3 * (1-p4),
"1001" = p1 * (1-p2) * (1-p3) * p4,
"1100" = p1 * p2 * (1-p3) * (1-p4),
"0111" = (1-p1) * p2 * p3 * p4,
"1011" = p1 * (1-p2) * p3 * p4,
"1101" = p1 * p2 * (1-p3) * p4,
"1110" = p1 * p2 * p3 * (1-p4),
"1111" = p1 * p2 * p3 * p4)
}
o2y <- matrix(1, 4, 15)
class(capSummary) <- "matrix"
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
crNull <- multinomPois(~1 ~1, umf.cr1, engine = "R")
p <- matrix(0.4,2,4)
crPiFun(p)
rm(p)
crDay <- multinomPois(~dayOfYear ~1, umf.cr1, engine = "R")
matrix(c("1","2","3"), 50, 3, byrow = T)
capSummary
o2y <- matrix(1, 4, 15)
class(capSummary) <- "matrix"
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
crNull <- multinomPois(~1 ~1, umf.cr1, engine = "R")
o2y
o2y <- matrix(1, 3, 15)
class(capSummary) <- "matrix"
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
crNull <- multinomPois(~1 ~1, umf.cr1, engine = "R")
o2y <- matrix(1, 5, 15)
class(capSummary) <- "matrix"
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
crNull <- multinomPois(~1 ~1, umf.cr1, engine = "R")
o2y <- matrix(1, 3, 15)
class(capSummary) <- "matrix"
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
crNull <- multinomPois(~1 ~1, umf.cr1, engine = "R")
o2y <- matrix(1, 7, 15)
class(capSummary) <- "matrix"
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
crNull <- multinomPois(~1 ~1, umf.cr1, engine = "R")
o2y <- matrix(1, 214, 15)
class(capSummary) <- "matrix"
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
crNull <- multinomPois(~1 ~1, umf.cr1, engine = "R")
o2y <- matrix(1, 1, 15)
class(capSummary) <- "matrix"
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
crNull <- multinomPois(~1 ~1, umf.cr1, engine = "R")
## How do removal models compare to full encounter histories? Following code will treat the
## surveys as capture/recapture efforts, thus retaining the full encounter history. This
## differs from the removal models, which truncate the history after the first detection.
captHistory <-
encounters %>%
replace(is.na(.), 0) %>%
mutate(captureHistory = paste(interval1, interval2, interval3, interval4, sep = ""))
captHistory$captureHistory <- factor(captHistory$captureHistory,
levels = c("0001","0010","0100","1000",
"0011","0101","0110","1010","1001","1100",
"0111","1011","1101","1110","1111"))
capSummary <- table(captHistory$Site_ID, captHistory$captureHistory)
crPiFun <- function(p) {
p1 <- p[,1]
p2 <- p[,2]
p3 <- p[,3]
p4 <- p[,4]
cbind("0001" = (1-p1) * (1-p2) * (1-p3) * p4,
"0010" = (1-p1) * (1-p2) * p3 * (1-p4),
"0100" = (1-p1) * p2 * (1-p3) * (1-p4),
"1000" = p1 * (1-p2) * (1-p3) * (1-p4),
"0011" = (1-p1) * (1-p2) * p3 * p4,
"0101" = (1-p1) * p2 * (1-p3) * p4,
"0110" = (1-p1) * p2 * p3 * (1-p4),
"1010" = p1 * (1-p2) * p3 * (1-p4),
"1001" = p1 * (1-p2) * (1-p3) * p4,
"1100" = p1 * p2 * (1-p3) * (1-p4),
"0111" = (1-p1) * p2 * p3 * p4,
"1011" = p1 * (1-p2) * p3 * p4,
"1101" = p1 * p2 * (1-p3) * p4,
"1110" = p1 * p2 * p3 * (1-p4),
"1111" = p1 * p2 * p3 * p4)
}
o2y <- matrix(1, 4, 15)
class(capSummary) <- "matrix"
umf.cr1 <- unmarkedFrameMPois(y = capSummary, siteCovs = covs, piFun = "crPiFun", obsToY = o2y)
crNull <- multinomPois(~1 ~1, umf.cr1, engine = "R")
crDay <- multinomPois(~dayOfYear ~1, umf.cr1, engine = "R")
crNull
crDay
backTransform(crNull, type = "state")
backTransform(crNull, type = "det")
#STAN model of the same:
crSTANnull <- stan_multinomPois(~1 ~1, umf.cr1, chains = 3, iter = 300)
crPredictP <- data.frame(dayOfYear = seq(min(covs$dayOfYear), max(covs$dayOfYear), by = 1))
crPredictPdata <- data.frame(dayOfYear = seq(min(covs$dayOfYear), max(covs$dayOfYear), by = 1))
rm(crPredictP)
crPredictP <- predict(crDay, type = "det", newdata = crPredictPdata, appendData = TRUE)
plot(Predicted ~ dayOfYear, crPredictP, type = "l")
ggplot(data = crPredictP, aes(x = dayOfYear, y = Predicted)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = dayOfYear, y = Predicted), color = "black") +
xlab("Day of year") + ylab ("Availability for detection") +
theme_bw()
removalDaySTAN <- stan_multinomPois(~scale(dayOfYear) ~1, removalFrame, chains=3, iter=300, cores = 3)
removalDaySTAN
removalDaySTANframe <- plot_effects(removalDaySTAN, "det")
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = covariate, y = mn), color = "black") +
xlab("Day of year") + ylab ("Availability for detection") +
theme_bw()
tableRemovalAIC <- aictab(cand.set = fmRemovalList, second.ord = T, sort = T)
removalPredictPdata <- data.frame(dayOfYear = seq(min(covs$dayOfYear), max(covs$dayOfYear), by = 1))
removalPredictP <- predict(removalDay, type = "det", newdata = removalPredictPdata, appendData = TRUE)
ggplot(data = removalPredictP, aes(x = dayOfYear, y = Predicted)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = dayOfYear, y = Predicted), color = "black") +
xlab("Day of year") + ylab ("Availability for detection") +
theme_bw()
summary(removalDay)
summary(removalTemp)
removalDay <- multinomPois(~scale(dayOfYear) ~1, data = removalFrame)
summary(removalDay)
removalPredictPdata <- data.frame(dayOfYear = seq(min(covs$dayOfYear), max(covs$dayOfYear), by = 1))
removalPredictP <- predict(removalDay, type = "det", newdata = removalPredictPdata, appendData = TRUE)
ggplot(data = removalPredictP, aes(x = dayOfYear, y = Predicted)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = dayOfYear, y = Predicted), color = "black") +
xlab("Day of year") + ylab ("Availability for detection") +
theme_bw()
fmRemovalList <- list("removalNull" = removalNull, "removalDay" = removalDay, "removalTemp" = removalTemp,
"removalNoise" = removalNoise, "removalMAS" = removalMAS)
aictab(cand.set = fmRemovalList, second.ord = T, sort = T)
removalMAS <- multinomPois (~scale(mas) ~1, data = removalFrame)
fmRemovalList <- list("removalNull" = removalNull, "removalDay" = removalDay, "removalTemp" = removalTemp,
"removalNoise" = removalNoise, "removalMAS" = removalMAS)
aictab(cand.set = fmRemovalList, second.ord = T, sort = T)
lc <- linearComb(removalDay, c(Int = 1, dayOfYear = median(covs$dayOfYear)), type = "det")
backTransform(lc)
lc <- linearComb(removalDay, c(Int = 1, dayOfYear = median(scale(covs$dayOfYear))), type = "det")
backTransform(lc)
crTemp <- multinomPois(~temp ~1, data = umf.cr1, engine = "R")
crNoise <- multinomPois(~avgNoise ~1, data = umf.cr1, engine = "R")
crMAS <- multinomPois (~mas ~1, data = umf.cr1, engine = "R")
fmCRList <- list("crNull" = crNull, "crDay" = crDay, "crTemp" = crTemp,
"crNoise" = crNoise, "crMAS" = crMAS)
aictab(cand.set = fmRemovalList, second.ord = T, sort = T)
lc <- linearComb(crDay, c(Int = 1, dayOfYear = median(covs$dayOfYear)), type = "det")
backTransform(lc)
removalPredictPdata <- data.frame(dayOfYear = seq(min(covs$dayOfYear), max(covs$dayOfYear), by = 1))
removalPredictP <- predict(removalDay, type = "det", newdata = removalPredictPdata, appendData = TRUE)
ggplot(data = removalPredictP, aes(x = dayOfYear, y = Predicted)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = dayOfYear, y = Predicted), color = "black") +
xlab("Day of year") + ylab ("Availability for detection") +
theme_bw()
drTemp <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~dayOfYear,
distanceformula = ~temp, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
drMAS <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~dayOfYear,
distanceformula = ~mas, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
drNoise <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~avgNoise,
distanceformula = ~temp, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
drNull <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~1,
distanceformula = ~1, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
## Distance removal with day-of-year as covariate on distance:
drDay <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~dayOfYear,
distanceformula = ~dayOfYear, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
fmList <- list("drNull" = drNull, "drDay" = drDay, "drNoise" = drNoise, "drMAS" = drMAS, "drTemp" = drTemp)
tableDistanceRemovalAIC <- aictab(cand.set = fmList, second.ord = T, sort = T)
summary(fmList)
summary(drNull)
summary(drDay)
summary(drNoise)
summary(drTemp)
summary(drMAS)
aictab()
aictab
backTransform(removalDay, type = "state")
pi*400^2
pi*400^2*0.292
0.292/0.502
backTransform(crDay, type = "state")
0.176/0.502
0.14 * 0.06
summary(drDay)
summary(drNull)
summary(drMAS)
summary(drTemp)
summary(drNoise)
summary(drNull)
# Get p
getPdistrem <- function(x) {
sig <- backTransform(linearComb(drDay,c(1,171), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
return(p)
}
getPdistrem()
backTransform(drDay, type = "removal")
backTransform(drDay, type = "rem")
## Function to calculate the prob. of detection,
## where p = detection prob. from distance sampling,
## and d = detection prob. from removal sampling,
## and P*D = overall detectability.
## I think due to the uncertainty and very small estimates for each part of the equation,
## the bootstrap function is failing. Not sure how to get to a CI around P.
getPdistrem <- function(x) {
d <- backTransform(x@estimates@estimates$rem)@estimate
sig <- backTransform(x@estimates@estimates$dist)@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*d
return(Pd)
}
getPdistrem(drNull)
## Function to calculate the prob. of detection,
## where p = detection prob. from distance sampling,
## and d = detection prob. from removal sampling,
## and P*D = overall detectability.
## I think due to the uncertainty and very small estimates for each part of the equation,
## the bootstrap function is failing. Not sure how to get to a CI around P.
getPdistrem <- function(x) {
d <- backTransform(x@estimates@estimates$rem)@estimate
sig <- backTransform(x@estimates@estimates$dist)@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*d
return(Pd)
return(d)
}
getPdistrem(drNull)
## Function to calculate the prob. of detection,
## where p = detection prob. from distance sampling,
## and d = detection prob. from removal sampling,
## and P*D = overall detectability.
## I think due to the uncertainty and very small estimates for each part of the equation,
## the bootstrap function is failing. Not sure how to get to a CI around P.
getPdistrem <- function(x) {
d <- backTransform(x@estimates@estimates$rem)@estimate
sig <- backTransform(x@estimates@estimates$dist)@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*d
return(d)
}
getPdistrem(drNull)
0.22*0.06
## Function to calculate the prob. of detection,
## where p = detection prob. from distance sampling,
## and d = detection prob. from removal sampling,
## and P*D = overall detectability.
## I think due to the uncertainty and very small estimates for each part of the equation,
## the bootstrap function is failing. Not sure how to get to a CI around P.
getPdistrem <- function(x) {
d <- backTransform(x@estimates@estimates$rem)@estimate
sig <- backTransform(x@estimates@estimates$dist)@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*d
return(Pd)
}
getPdistrem(drNull)
drBest <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~dayOfYear,
distanceformula = ~dayOfYear, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
summary(drBest)
300.05-298.04
301.54-298.04
302.29-298.04
## No AICTAB function for dealing with gdistremoval, so this doesn't work:
fmList <- list("drNull" = drNull, "drDay" = drDay, "drNoise" = drNoise, "drMAS" = drMAS, "drTemp" = drTemp)
ms <- modSel(fmList)
## No AICTAB function for dealing with gdistremoval, so this doesn't work:
fmList <- fitList("drNull" = drNull, "drDay" = drDay, "drNoise" = drNoise, "drMAS" = drMAS, "drTemp" = drTemp)
## No AICTAB function for dealing with gdistremoval, so this doesn't work:
fmList <- fitList(Null = drNull, Day = drDay, Noise = drNoise, Time-of-day = drMAS, temp = drTemp)
## No AICTAB function for dealing with gdistremoval, so this doesn't work:
fmList <- fitList(Null=drNull, Day=drDay, Noise=drNoise, Time-of-day=drMAS, temp=drTemp)
## No AICTAB function for dealing with gdistremoval, so this doesn't work:
fmList <- fitList(Null=drNull, Day=drDay, Noise=drNoise, Time=drMAS, temp=drTemp)
drBest
drDay
## Distance removal with day-of-year as covariate on distance:
drDay <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~1,
distanceformula = ~dayOfYear, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
summary(drDay)
summary drBest
summary (drBest)
summary(drNull)
drMAS <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~mas,
distanceformula = ~dayOfYear, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
summary(drMAS)
drNoise <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~avgNoise,
distanceformula = ~dayOfYear, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
summary(drNoise)
drTemp <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~temp,
distanceformula = ~dayOfYear, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
summary(drTemp)
drDayRemOnly <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~dayOfYear,
distanceformula = ~1, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
summary(drDayRemOnly)
drMASRemOnly <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~MAS,
distanceformula = ~1, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
drMASRemOnly <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~mas,
distanceformula = ~1, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
summary(drMASRemOnly)
summary(drNull)
low <- 296.45
297.98 - low
298.04 - low
298.44-low
298.66-low
298.72-low
300.09-low
getPdistrem()
getPdistrem <- function(x) {
sig <- backTransform(linearComb(drDay,c(1,171), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
return(p)
}
getPdistrem()
parboot(drNull, getPdistrem, nsim = 25, report = 1)
backTransform(drDay, type = "distance")
backTransform(drDay, type = "dist")
backTransform(drDay, type = "rem")
backTransform(linearComb(drDay,c(1,171), type = "dist"))
median(covs$dayOfYear)
# Get p
getPdistrem <- function(x) {
sig <- backTransform(linearComb(drDay,c(1,150), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
return(p)
}
getPdistrem()
parboot(drNull, getPdistrem, nsim = 25, report = 1)
backTransform(drDay, type = "rem")
## Function to calculate the prob. of detection,
## where p = detection prob. from distance sampling,
## and d = detection prob. from removal sampling,
## and P*D = overall detectability.
## I think due to the uncertainty and very small estimates for each part of the equation,
## the bootstrap function is failing. Not sure how to get to a CI around P.
getPhatDistRem <- function(x) {
d <- backTransform(x@estimates@estimates$rem)@estimate
sig <- backTransform(x@estimates@estimates$dist)@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*d
return(Pd)
}
getPhatDistRem(drDay)
getPD <- function(x) {
d <- backTransform(linearComb(drDay,c(1,0), type = "rem"))
sig <- backTransform(linearComb(drDay,c(1,0), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*(d@estimate)
return(Pd)
}
getPD(drDay)
getPD <- function(x) {
d <- backTransform(drDay, type = "rem"))
getPD <- function(x) {
d <- backTransform(drDay, type = "rem")
sig <- backTransform(linearComb(drDay,c(1,0), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*(d@estimate)
return(Pd)
}
getPD(drDay)
return(P)
getPD <- function(x) {
d <- backTransform(drDay, type = "rem")
sig <- backTransform(linearComb(drDay,c(1,0), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*(d@estimate)
return(P)
}
getPD <- function(x) {
d <- backTransform(drDay, type = "rem")
sig <- backTransform(linearComb(drDay,c(1,0), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*(d@estimate)
return(p)
}
getPD(drDay)
backTransform(drDay, type = "rem")
backTransform(linearComb(drDay,c(1,0), type = "dist"))
backTransform(linearComb(drDay,c(1,171), type = "dist"))
getPD <- function(x) {
d <- backTransform(drDay, type = "rem")
sig <- backTransform(linearComb(drDay,c(1,171), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*(d@estimate)
return(p)
}
getPD(drDay)
parboot(drDay, getPD, nsim = 25, report = 25)
getPD <- function(x) {
d <- backTransform(drDay, type = "rem")
sig <- backTransform(linearComb(drDay,c(1,171), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*(d@estimate)
return(Pd)
}
getPD(drDay)
backTransform(drDay, type = "state")
backTransform(drDay, type = "lambda")
