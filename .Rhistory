summary(drNull)
## To show that the basic removal model produces the same estimate as the gdistremoval function
removalFrame <- unmarkedFrameMPois(y = yRemoval, siteCovs = covs, type = "removal")
backTransform(linearComb(removalDay['det'], c(1,dayOfYear = min(covs$dayOfYear,0))))@estimate
backTransform(removalNull, type = "det")
lc <- linearComb(removalDay, c(Int = 1, dayOfYear = min(covs$dayOfYear)), type = "det")
backTransform(lc)
lc <- linearComb(removalDay, c(Int = 1, dayOfYear = max(covs$dayOfYear)), type = "det")
backTransform(lc)
backTransform(removalNull, type = "state")
install.packages("ubms")
library(ubms)
# STAN model of the same:
removalDaySTAN <- stan_multinomPois(~dayOfYear ~1, removalFrame, chains=3, iter=300)
# STAN model of the same:
removalDaySTAN <- stan_multinomPois(~scale(dayOfYear) ~1, removalFrame, chains=3, iter=300, cores = 3)
summary(removalDaySTAN)
removalDaySTAN
plot_effects(removalDaySTAN, "det")
plot_effects(removalDaySTAN, "det", xlab = "DF")
plotte <- plot_effects(removalDaySTAN, "det")
ggplot(data = plotte$data, aes(x = covariate, y = mn)) + geom_line()
rm(plotte)
removalDaySTANframe <- plot_effects(removalDaySTAN, "det")
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) + geom_line() +
geom_ribbon(aes(ymin = lower, ymax = upper))
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) + geom_line() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = NULL))
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) + geom_line() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "gray"))
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) + geom_line() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = gray))
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) + geom_line() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "gray80"))
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) + geom_line() +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = "grey80"))
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) + geom_line() +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80"))
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) + geom_line() +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80")) +
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) + geom_line() +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80") +
xlab("Day of year") + ylab ("Availability for detection")
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80") +
geom_line(aes(x = covariate, y = mn, color = "black")) +
xlab("Day of year") + ylab ("Availability for detection")
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80") +
geom_line(aes(x = covariate, y = mn), color = "black")) +
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80") +
geom_line(aes(x = covariate, y = mn), color = "black") +
xlab("Day of year") + ylab ("Availability for detection")
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80") +
geom_line(aes(x = covariate, y = mn), color = "black") +
xlab("Day of year") + ylab ("Availability for detection") +
theme_minimal()
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80") +
geom_line(aes(x = covariate, y = mn), color = "black") +
xlab("Day of year") + ylab ("Availability for detection") +
theme_bw()
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80", alpha = 0.8) +
geom_line(aes(x = covariate, y = mn), color = "black") +
xlab("Day of year") + ylab ("Availability for detection") +
theme_bw()
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = covariate, y = mn), color = "black") +
xlab("Day of year") + ylab ("Availability for detection") +
theme_bw()
## Distance model with STAN
distanceHNDaySTAN <- stan_distsamp(~dayOfYear ~1, data = umf, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", chains = 3, iter = 300, cores = 3)
## Distance model with STAN
distanceHNDaySTAN <- stan_distsamp(~scale(dayOfYear) ~1, data = umf, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", chains = 3, iter = 300, cores = 3)
## Distance model with STAN
umfDSSTAND <- unmarkedFrameDS(y = as.matrix(yDat), siteCovs = as.data.frame(covs),
survey = "point", dist.breaks = c(0,0.025,0.1,0.2,0.4), unitsIn = "km")
distanceHNDaySTAN <- stan_distsamp(~scale(dayOfYear) ~1, data = umf, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", chains = 3, iter = 300, cores = 3)
distanceHNDaySTAN <- stan_distsamp(~scale(dayOfYear) ~1, data = umf, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", chains = 3, iter = 300, cores = 3,
init_r = 0.1)
distanceHNDaySTAN <- stan_distsamp(~scale(dayOfYear) ~1, data = umf, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", chains = 3, iter = 300, cores = 3,
inits = "0")
distanceHNDaySTAN <- stan_distsamp(~scale(dayOfYear) ~1, data = umf, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", chains = 3, iter = 300, cores = 3,
init_r = "0")
distanceNullSTAN <- stan_distsamp(~1 ~1, data = umf, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", chains = 3, iter = 300, cores = 3)
# Predict seasonal change in detectability'
dsPredictionFrame <- data.frame(dayOfYear = seq(min(covs$dayOfYear), max(covs$dayOfYear), by = 1))
View(dsPredictionFrame)
predict(hnDay, data = dsPredictionFrame)
# Predict seasonal change in detectability'
dsPredictionFrame <- data.frame(dayOfYear = seq(min(covs$dayOfYear), max(covs$dayOfYear), by = 1))
predict(hnDay, data = dsPredictionFrame, type = "det")
min(covs$dayOfYear)
for (i in 158:length(covs$dayOfYear)) {
sig[i] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
ea[i] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[i])$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
return (out)
}
backTransform(linearComb(hnDay['det'], c(1, 158)))@estimate
length(dovs$dayOfYear)
length(covs$dayOfYear)
max(covs$dayOfYear)
for (i in 158:181 {
for (i in 158:181) {
sig[i] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
ea[i] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[i])$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
return (out)
}
for (i in 1:10) {
sig[i] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
ea[i] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[i])$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
return (out)
}
for (i in 1:10) {
sig[[i]] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
ea[i] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[i])$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
return (out)
}
for (i in 1:10) {
sig[[i]] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
ea[[i]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i]])$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
return (out)
}
for (i in 1:10) {
sig[[i]] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
}
sig <- vector("double", length = 10)
for (i in 1:10) {
sig[[i]] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
}
sig
sig <- matrix(nrow = 10, ncol = 2)
for (i in 1:10) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
}
View(sig)
sig <- matrix(nrow = 10, ncol = 3)
for (i in 1:10) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
}
sig <- matrix(nrow = 10, ncol = 4)
for (i in 1:10) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
}
View(surveyData)
sig <- matrix(nrow = 10, ncol = 4)
sig <- matrix(nrow = 33, ncol = 4)
for (i in 181:214) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i)))@estimate
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
}
214-181
sig <- matrix(nrow = 33, ncol = 4)
for (i in 1:10) {
for (j in 181:214) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, j)))@estimate
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
}
View(sig)
min(covs$dayOfYear)
max(covs$dayOfYear)
sig <- matrix(nrow = 33, ncol = 4)
for (i in 1:33) {
for (j in 158:181) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, j)))@estimate
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
}
View(sig)
for (i in 1:33) {
for (j in 158:181) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, [[j]])))@estimate
backTransform(linearComb(hnDay['det'], c(1, 158)))@estimate
backTransform(linearComb(hnDay['det'], c(1, 181)))@estimate
for (j in 158:181) {
for (i in 1:33) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, j)))@estimate
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
}
View(sig)
for (i in 1:33) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
}
View(sig)
dimnames(sig) <- list(c((NULL),c("sigma", "ea", "er", "p")))
dimnames(sig) <- list(c("sigma", "ea", "er", "p"))
colnames(sig) <- list(c("sigma", "ea", "er", "p"))
colnames(sig) <- c("sigma", "ea", "er", "p")
getPcovs <- function(hnDay) {
sig <- backTransform(linearComb(hnDay['det'], c(1, median(covs$dayOfYear))))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
return(out)
}
getPcovs()
getPcovs(hnDay)
parboot(hnDay, getPcovs[[1]], nsim = 25, report = 1)
parboot(hnDay, getPcovs$p, nsim = 25, report = 1)
cc <- getPcovs(hnDay)
parboot(hnDay, getPcovs[1,], nsim = 25, report = 1)
parboot(hnDay, cc[1,], nsim = 25, report = 1)
parboot(hnDay, cc[,1], nsim = 25, report = 1)
cc[,1]
rm(cc)
parboot(hnDay, getPcovs, nsim = 10, report = 1)
bsEst <- parboot(hnDay, getPcovs, nsim = 10, report = 1)
percentile(bsEst@t.star$p,0.95)
quantile(bsEst@t.star$p,probs = 0.95)
bsEst@t.star
bsEst@t.star[,1]
quantile(bsEst@t.star[,1], probs = 0.95)
quantile(bsEst@t.star[,1], probs = 0.25)
quantile(parboot(hnDay,getPcovs,nsim = 10, report =1)@t.star[,1],probs = 0.95)
cc<-quantile(parboot(hnDay,getPcovs,nsim = 10, report =1)@t.star[,1],probs = 0.95)
cc
## Loop function for calculating P-hat across days of the season
sig <- matrix(nrow = 33, ncol = 5)
colnames(sig) <- c("sigma", "ea", "er", "p","lowerCI")
for (i in 1:33) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
sig[[i,5]] <- quantile(parboot(hnDay, getPcovs, nsim = 25, report = 50)@t.star[,1],probs = 0.25)
}
View(sig)
for (j in 1:33) {
for (i in 1:33) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
}
getPcovs <- function(hnDay) {
sig <- backTransform(linearComb(hnDay['det'], c(1, j+157)))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
}
sig[[i,5]] <- quantile(parboot(hnDay,getPcovs,nsim=10,report=10)@t.star[,1],probs = 0.25)
}
View(sig)
for (i in 1:33) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
getPcovsL <- function(hnDay) {
sig <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
}
sig[[i,5]] <- quantile(parboot(hnDay,getPcovsL,nsim=10,report=10)@t.star[,1],probs = 0.25)
}
View(sig)
for (i in 1:33) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
getPcovsL <- function(hnDay) {
sig <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
}
sig[[i,5]] <- quantile(parboot(hnDay,getPcovsL,nsim=10,report=10)@t.star[,1],probs = 0.025)
}
View(sig)
## Loop function for calculating P-hat across days of the season
sig <- matrix(nrow = 33, ncol = 6)
colnames(sig) <- c("sigma", "ea", "er", "p","lowerCI", "upperCI")
for (i in 1:33) {
sig[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
sig[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=sig[[i,1]])$value # effective area
sig[[i,3]] <- sqrt(sig[[i,2]] / pi) # effective radius
sig[[i,4]] <- sig[[i,2]] / (pi*400^2) #detection probability
getPcovsL <- function(hnDay) {
sig <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
}
sig[[i,5]] <- quantile(parboot(hnDay,getPcovsL, nsim = 10, report = 10)@t.star[,1],probs = 0.025)
sig[[i,6]] <- quantile(parboot(hnDay,getPcovsL, nsim = 10, report = 10)@t.star[,1], probs = 0.975)
}
View(sig)
rm(bsEst)
rm(sig)
## Loop function for calculating P-hat across days of the season
distanceCovPred <- matrix(nrow = 33, ncol = 6)
colnames(distanceCovPred) <- c("sigma", "ea", "er", "p","lowerCI", "upperCI")
for (i in 1:33) {
distanceCovPred[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
distanceCovPred[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=distanceCovPred[[i,1]])$value # effective area
distanceCovPred[[i,3]] <- sqrt(distanceCovPred[[i,2]] / pi) # effective radius
distanceCovPred[[i,4]] <- distanceCovPred[[i,2]] / (pi*400^2) #detection probability
getPcovsL <- function(hnDay) {
sig <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
}
distanceCovPred[[i,5]] <- quantile(parboot(hnDay,getPcovsL, nsim = 10, report = 10)@t.star[,1],probs = 0.025)
distanceCovPred[[i,6]] <- quantile(parboot(hnDay,getPcovsL, nsim = 10, report = 10)@t.star[,1], probs = 0.975)
}
View(distanceCovPred)
## Loop function for calculating P-hat across days of the season
distanceCovPred <- matrix(nrow = 33, ncol = 6) #create a matrix for output
colnames(distanceCovPred) <- c("sigma", "ea", "er", "p","lowerCI", "upperCI") #give the columns names
for (i in 1:33) { #this loops through 33 days of the year to generate estimates of p-hat
distanceCovPred[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
distanceCovPred[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=distanceCovPred[[i,1]])$value # effective area
distanceCovPred[[i,3]] <- sqrt(distanceCovPred[[i,2]] / pi) # effective radius
distanceCovPred[[i,4]] <- distanceCovPred[[i,2]] / (pi*400^2) #detection probability
getPcovsL <- function(hnDay) { #this defines the function that 'parboot' will use
sig <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
} #following lines are for pulling out upper and lower 95% Ci from bootstrap
distanceCovPred[[i,5]] <- quantile(parboot(hnDay,getPcovsL, nsim = 100, report = 100)@t.star[,1],probs = 0.025)
distanceCovPred[[i,6]] <- quantile(parboot(hnDay,getPcovsL, nsim = 100, report = 100)@t.star[,1], probs = 0.975)
}
View(distanceHNDaySTAN)
for (i in 1:33) { #this loops through 33 days of the year to generate estimates of p-hat
distanceCovPred[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
distanceCovPred[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=distanceCovPred[[i,1]])$value # effective area
distanceCovPred[[i,3]] <- sqrt(distanceCovPred[[i,2]] / pi) # effective radius
distanceCovPred[[i,4]] <- distanceCovPred[[i,2]] / (pi*400^2) #detection probability
getPcovsL <- function(hnDay) { #this defines the function that 'parboot' will use
sig <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
} #following lines are for pulling out upper and lower 95% Ci from bootstrap
distanceCovPred[[i,5]] <- quantile(parboot(hnDay,getPcovsL, nsim = 10, report = 10)@t.star[,1],probs = 0.025)
distanceCovPred[[i,6]] <- quantile(parboot(hnDay,getPcovsL, nsim = 10, report = 10)@t.star[,1], probs = 0.975)
}
for (i in 1:33) { #this loops through 33 days of the year to generate estimates of p-hat
distanceCovPred[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
distanceCovPred[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=distanceCovPred[[i,1]])$value # effective area
distanceCovPred[[i,3]] <- sqrt(distanceCovPred[[i,2]] / pi) # effective radius
distanceCovPred[[i,4]] <- distanceCovPred[[i,2]] / (pi*400^2) #detection probability
getPcovsL <- function(hnDay) { #this defines the function that 'parboot' will use
sig <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
} #following lines are for pulling out upper and lower 95% Ci from bootstrap
distanceCovPred[[i,5]] <- quantile(parboot(hnDay,getPcovsL, nsim = 100, report = 10)@t.star[,1],probs = 0.025)
distanceCovPred[[i,6]] <- quantile(parboot(hnDay,getPcovsL, nsim = 100, report = 10)@t.star[,1], probs = 0.975)
}
for (i in 1:33) { #this loops through 33 days of the year to generate estimates of p-hat
distanceCovPred[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
distanceCovPred[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=distanceCovPred[[i,1]])$value # effective area
distanceCovPred[[i,3]] <- sqrt(distanceCovPred[[i,2]] / pi) # effective radius
distanceCovPred[[i,4]] <- distanceCovPred[[i,2]] / (pi*400^2) #detection probability
getPcovsL <- function(hnDay) { #this defines the function that 'parboot' will use
sig <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
} #following lines are for pulling out upper and lower 95% Ci from bootstrap
distanceCovPred[[i,5]] <- quantile(parboot(hnDay,getPcovsL, nsim = 100, report = 100, ncores = 1)@t.star[,1],probs = 0.025)
distanceCovPred[[i,6]] <- quantile(parboot(hnDay,getPcovsL, nsim = 100, report = 100, ncores = 1)@t.star[,1], probs = 0.975)
}
View(distanceCovPred)
predict(hnDay, data = dsPredictionFrame, type = "det")
rm(list = c(dsPredictionFrame))
rm(dsPredictionFrame)
ggplot(data = distanceCovPred) +
geom_ribbon(aes(ymin = lowerCI, ymax = upperCI), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = seq(158:181, by =1), y = p), color = "black") +
xlab("Day of year") + ylab ("Probability of detection") +
theme_bw()
ggplot(data = as.data.frame(distanceCovPred)) +
geom_ribbon(aes(ymin = lowerCI, ymax = upperCI), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = seq(158:181, by =1), y = p), color = "black") +
xlab("Day of year") + ylab ("Probability of detection") +
theme_bw()
distanceCovPred[,7] <- seq(158, 181, 1)
distanceCovPred[,7] <- cbind(seq(158, 181, 1))
daysForMatrix <- seq(158, 181, 1)
max(covs$dayOfYear)
min(covs$dayOfYear)
181-158
## Predict seasonal changes in P-hat
## Loop function for calculating P-hat across days of the season
distanceCovPred <- matrix(nrow = 24, ncol = 7) #create a matrix for output
colnames(distanceCovPred) <- c("sigma", "ea", "er", "p","lowerCI", "upperCI", "Day") #give the columns names
for (i in 1:24) { #this loops through 24 days of the year to generate estimates of p-hat
distanceCovPred[[i,1]] <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate # this is a kludge to index days (i.e., lowest value = day 158)
distanceCovPred[[i,2]] <- 2*pi * integrate(grhn, 0, 400, sigma=distanceCovPred[[i,1]])$value # effective area
distanceCovPred[[i,3]] <- sqrt(distanceCovPred[[i,2]] / pi) # effective radius
distanceCovPred[[i,4]] <- distanceCovPred[[i,2]] / (pi*400^2) #detection probability
getPcovsL <- function(hnDay) { #this defines the function that 'parboot' will use
sig <- backTransform(linearComb(hnDay['det'], c(1, i+157)))@estimate
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
out <- c(p = p , er = er)
} #following lines are for pulling out upper and lower 95% Ci from bootstrap; parallel process didn't work, so had to set cores = 1
distanceCovPred[[i,5]] <- quantile(parboot(hnDay,getPcovsL, nsim = 100, report = 100, ncores = 1)@t.star[,1],probs = 0.025)
distanceCovPred[[i,6]] <- quantile(parboot(hnDay,getPcovsL, nsim = 100, report = 100, ncores = 1)@t.star[,1], probs = 0.975)
}
distanceCovPred[,7]<- seq(158, 181, 1)
View(distanceCovPred)
ggplot(data = as.data.frame(distanceCovPred)) +
geom_ribbon(aes(ymin = lowerCI, ymax = upperCI), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = Day, y = p), color = "black") +
xlab("Day of year") + ylab ("Probability of detection") +
theme_bw()
ggplot(data = as.data.frame(distanceCovPred, x = Day, y = p)) +
geom_ribbon(aes(ymin = lowerCI, ymax = upperCI), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = Day, y = p), color = "black") +
xlab("Day of year") + ylab ("Probability of detection") +
theme_bw()
ggplot(data = as.data.frame(distanceCovPred), aes(x = Day, y = p)) +
geom_ribbon(aes(ymin = lowerCI, ymax = upperCI), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = Day, y = p), color = "black") +
xlab("Day of year") + ylab ("Probability of detection") +
theme_bw()
ggplot(data = removalDaySTANframe$data, aes(x = covariate, y = mn)) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "grey80", alpha = 0.5) +
geom_line(aes(x = covariate, y = mn), color = "black") +
xlab("Day of year") + ylab ("Availability for detection") +
theme_bw()
aictab(cand.set = fmRemovalList, second.ord = T, sort = T)
## Distance removal with day-of-year as covariate on distance:
drDay <- gdistremoval(lambdaformula = ~1, phiformula = ~1, removalformula = ~dayOfYear,
distanceformula = ~dayOfYear, data = umfDR, keyfun = "halfnorm",
output = "density", unitsOut = "kmsq", mixture = "ZIP")
summary(drDay)
getPD <- function(x) {
d <- backTransform(drDay, type = "rem")
sig <- backTransform(linearComb(drDay,c(1,0), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*(d@estimate)
return(Pd)
}
getPD(drDay)
backTransform(drDay, type = "rem")
backTransform(linearComb(drDay,c(1,0,0), type = "dist"))
backTransform(linearComb(drDay,c(1,0), type = "dist"))
backTransform(linearComb(drDay,c(1,0), type = "rem"))
getPD <- function(x) {
d <- backTransform(linearComb(drDay,c(1,0), type = "rem"))
sig <- backTransform(linearComb(drDay,c(1,0), type = "dist"))
ea <- 2*pi * integrate(grhn, 0, 400, sigma=sig@estimate)$value # effective area
er <- sqrt(ea / pi) # effective radius
p <- ea / (pi*400^2) #detection probability
Pd <- p*(d@estimate)
return(Pd)
}
getPD(drDay)
