<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="John D. Lloyd">
<meta name="dcterms.date" content="2025-02-25">

<title>Comparative estimates of detectability in Willamette Valley Streaked Horned Larks</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="detectabilityReport2025_files/libs/clipboard/clipboard.min.js"></script>
<script src="detectabilityReport2025_files/libs/quarto-html/quarto.js"></script>
<script src="detectabilityReport2025_files/libs/quarto-html/popper.min.js"></script>
<script src="detectabilityReport2025_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="detectabilityReport2025_files/libs/quarto-html/anchor.min.js"></script>
<link href="detectabilityReport2025_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="detectabilityReport2025_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="detectabilityReport2025_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="detectabilityReport2025_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="detectabilityReport2025_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Comparative estimates of detectability in Willamette Valley Streaked Horned Larks</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>John D. Lloyd </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 25, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="summary" class="level1">
<h1>Summary</h1>
<p>Repeating 30-minute point counts twice did not yield increased detectability in comparison to a single 30-minute point count. Longer (30 minute) point counts did not increase estimates of detectability when compared to shorter (8 minute) point counts. Of the three options proposed, the optimal count strategy is to conduct two, 8-minute point counts on separate days.</p>
<p>I found no evidence that use of playbacks increased detectability.</p>
</section>
<section id="key-findings" class="level1">
<h1>Key findings</h1>
<ul>
<li><p>Estimates of detectability did not vary substantially among the three types of counting methods considered: two 30-minute counts on different days, one 30-minute count, or 2 8-minute counts on different days.</p></li>
<li><p>Estimates of detectability were not higher during count periods when playbacks were used.</p></li>
<li><p>Distance sampling is not well-suited to the system under study and likely underestimates detectability.</p></li>
</ul>
</section>
<section id="background-and-introduction" class="level1">
<h1>Background and introduction</h1>
<p>Ecostudies Institute requested an analysis of point-count data collected on Streaked Horned Larks in the Willamette Valley, Oregon that addressed two key questions:</p>
<ol type="1">
<li><p>Comparative estimates of detectability of Streaked Horned Larks under three different field approaches:</p>
<ul>
<li><p>Two 30-minute counts on separate days;</p></li>
<li><p>One 30-minute count; or</p></li>
<li><p>Two 8-minute counts on separate days.</p></li>
</ul></li>
<li><p>Comparative estimates of detectability during passive count periods and count periods during which recorded vocalizations were broadcast.</p></li>
</ol>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<p>Field data were provided as a text file by Ecostudies Institute. I used R package ‘umarked’ (<span class="citation" data-cites="Fiske2011">Kellner et al. (<a href="#ref-Kellner2023" role="doc-biblioref">2023</a>)</span>) version 1.5.0 in R version 4.4.2 (<span class="citation" data-cites="RCoreTeam2024">(<a href="#ref-RCoreTeam2024" role="doc-biblioref">R Core Team 2024</a>)</span>) to implement a combined removal and distance-sampling model (<span class="citation" data-cites="amundson2014">(<a href="#ref-amundson2014" role="doc-biblioref">Amundson, Royle, and Handel 2014</a>)</span>) to estimate detectability and address the key questions posed above. I did not consider models containing site covariates.</p>
</section>
<section id="results-and-discussion" class="level1">
<h1>Results and discussion</h1>
<section id="temporal-and-spatial-patterns-of-detection" class="level2">
<h2 class="anchored" data-anchor-id="temporal-and-spatial-patterns-of-detection">Temporal and spatial patterns of detection</h2>
<p>Most Streaked Horned Larks were detected for the first time during the first 8-minute count interval and very few birds were detected in close proximity to the observer (Fig. 1). Distance sampling assumes a uniform distribution of birds as a function of the distance to the observer, that birds do not move in response to the observer, and that birds closer to the observer are more readily perceptible; that most larks were detected far from the observer suggests that one or more of these assumptions is regularly violated. In this case, either larks close to the observer avoid singing, larks move away from the observer before they are counted, or that observation points are often located in non-habitat. No matter the reason, the dearth of observations near the observer almost certainly cause the distance-sampling algorithm to produce a significant underestimate of true detectability.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="medianDetDistances.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1. Most initial detections of singing Streaked Horned Larks occurred in the first count interval and most detections were more than 95 m from the observer.</figcaption>
</figure>
</div>
<p>Most Streaked Horned Larks are first detected during the first 9 minutes of each point count and 75% of all initial detections occur within the first 17 minutes (Fig. 2).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="medianDetTime.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2. Most initial detections of singing Streaked Horned Larks occurred early in the count period.</figcaption>
</figure>
</div>
</section>
<section id="comparative-estimates-of-detectability" class="level2">
<h2 class="anchored" data-anchor-id="comparative-estimates-of-detectability">Comparative estimates of detectability</h2>
<section id="two-30-minute-point-counts" class="level3">
<h3 class="anchored" data-anchor-id="two-30-minute-point-counts">Two 30-minute point counts</h3>
<p>The probability that a Streaked Horned Lark made itself available for detection during two 30-minute point counts conducted on different days was 0.62. The probability that an observer perceived a singing lark was 0.12. The joint probability that a Streaked Horned Lark was available for detection (i.e., that it sang) and that it was perceived by the observer was 0.08, implying that only 8% of individuals within 400 m of the observer (I assume based on previous analyses that this is the maximum distance at which larks are detected) make themselves available and are detected during two 30-minute counts conducted on different days. However, this estimate of overall detectability is almost certainly biased low because of the likely violations of the assumptions of distance sampling.</p>
</section>
<section id="one-30-minute-point-count" class="level3">
<h3 class="anchored" data-anchor-id="one-30-minute-point-count">One 30-minute point count</h3>
<p>The probability that a Streaked Horned Lark made itself available for detection during two 30-minute point counts conducted on different days was 0.63. The probability that an observer perceived a singing lark was 0.08. The joint probability that a Streaked Horned Lark was available for detection and that it was perceived by the observer was 0.05.</p>
</section>
<section id="two-8-minute-point-counts" class="level3">
<h3 class="anchored" data-anchor-id="two-8-minute-point-counts">Two 8-minute point counts</h3>
<p>The probability that a Streaked Horned Lark made itself available for detection during two 30-minute point counts conducted on different days was 0.70. The probability that an observer perceived a singing lark was 0.09. The joint probability that a Streaked Horned Lark was available for detection and that it was perceived by the observer was 0.06.</p>
</section>
<section id="passive-versus-playback-periods" class="level3">
<h3 class="anchored" data-anchor-id="passive-versus-playback-periods">Passive versus playback periods</h3>
<p>This analysis is based only on the removal model because the use of playbacks violates the assumptions of distance sampling (i.e., that birds do not move in response to the observer). As would be expected given the observed temporal patterns of detection (Fig. 2), playbacks did not evidently increase detections of Streaked Horned Larks (Fig. 3).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="passivePlayback.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3. Interval-specific estimates of detectability (availability, as estimated with a removal model) were lower during playback periods than during any of the passive periods.</figcaption>
</figure>
</div>
</section>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<ol type="1">
<li><p>The most efficient protocol considered was the repeated 8-minute count.</p></li>
<li><p>The least efficient protocol considered was the repeated 30-minute count.</p></li>
<li><p>Playbacks, at least as implemented in 2024, are not effective for increasing detectability of Streaked Horned Larks in the Willamette Valley.</p></li>
<li><p>Distance sampling does not seem to be a useful way to account for the imperfect detectability of singing Streaked Horned Larks. It appears to greatly underestimate perceptibility. This could be due to larks moving away from survey points in response to the observer, larks avoiding singing when observers are nearby, or because most point locations are immediately surrounded by non-habitat. If used in future analyses, estimates generated by distance sampling will likely overestimate the abundance and density of larks.</p></li>
</ol>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-amundson2014" class="csl-entry" role="listitem">
Amundson, Courtney L., J. Andrew Royle, and Colleen M. Handel. 2014. <span>“A Hierarchical Model Combining Distance Sampling and Time Removal to Estimate Detection Probability During Avian Point Counts.”</span> <em>The Auk</em> 131 (4): 476–94. <a href="https://doi.org/10.1642/auk-14-11.1">https://doi.org/10.1642/auk-14-11.1</a>.
</div>
<div id="ref-Fiske2011" class="csl-entry" role="listitem">
Fiske, Ian, and Richard Chandler. 2011. <span>“<span class="nocase">unmarked</span>: An <span>R</span> Package for Fitting Hierarchical Models of Wildlife Occurrence and Abundance.”</span> <em>Journal of Statistical Software</em> 43 (10): 1–23. <a href="https://www.jstatsoft.org/v43/i10/">https://www.jstatsoft.org/v43/i10/</a>.
</div>
<div id="ref-Kellner2023" class="csl-entry" role="listitem">
Kellner, Kenneth F., Adam D. Smith, J. Andrew Royle, Marc Kery, Jerrold L. Belant, and Richard B. Chandler. 2023. <span>“The <span class="nocase">unmarked</span> <span>R</span> Package: Twelve Years of Advances in Occurrence and Abundance Modelling in Ecology.”</span> <em>Methods in Ecology and Evolution</em> 14 (6): 1408–15. <a href="https://www.jstatsoft.org/v43/i10/">https://www.jstatsoft.org/v43/i10/</a>.
</div>
<div id="ref-RCoreTeam2024" class="csl-entry" role="listitem">
R Core Team. 2024. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="https://www.R-project.org/">https://www.R-project.org/</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>